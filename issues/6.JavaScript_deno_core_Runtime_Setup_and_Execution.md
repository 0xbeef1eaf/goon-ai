## Objective
Implement JavaScript execution environment using deno_core to run compiled TypeScript code and bridge to Rust bindings.
## Tasks
### 1. Runtime Module Structure
- [ ] Create runtime module:
  ```
  src/
  └── runtime/
      ├── mod.rs
      ├── runtime.rs        // deno_core runtime setup
      ├── ops.rs            // Rust ops exposed to JS
      └── executor.rs       // Execution coordination
  ```
### 2. deno_core Setup
- [ ] Initialize `JsRuntime`:
  - Configure V8 options
  - Set up runtime snapshot (optional for performance)
  - Configure async runtime integration with tokio
- [ ] Implement runtime creation:
  ```rust
  let runtime = JsRuntime::new(RuntimeOptions {
      module_loader: Some(Rc::new(CustomModuleLoader)),
      extensions: vec![extension],
      ..Default::default()
  });
  ```
### 3. Rust Op Registration
- [ ] Define ops (Rust functions callable from JS):
  - `op_show_image` - Display image window
  - `op_show_video` - Display video window
  - `op_play_audio` - Play audio file
  - `op_show_hypno` - Display hypno animation
  - `op_set_wallpaper` - Set desktop wallpaper
  - `op_show_prompt` - Show text prompt window
  - `op_open_website` - Open URL in browser
  - `op_get_asset` - Query asset by tag
  - `op_close_window` - Close specific window
  - `op_log` - Log message (for debugging)
- [ ] Use `deno_core::op2` macro for type-safe ops
- [ ] Implement permission checking in each op
### 4. Permission Enforcement
- [ ] Wrap each op with permission check:
  ```rust
  fn check_permission(state: &OpState, permission: &str) -> Result<()> {
      let perms = state.borrow::<Permissions>();
      if !perms.has(permission) {
          return Err(anyhow!("Permission denied: {}", permission));
      }
      Ok(())
  }
  ```
- [ ] Store active permissions in OpState
- [ ] Return clear errors for permission violations
### 5. JavaScript Bridge
- [ ] Create JavaScript wrapper functions:
  ```javascript
  async function showImage(path, options) {
      return await Deno.core.ops.op_show_image(path, options);
  }
  ```
- [ ] Initialize runtime with bridge code
- [ ] Make functions available in global scope
### 6. Execution Flow
- [ ] Implement execute method:
  1. Take compiled JavaScript
  2. Execute in isolated scope
  3. Capture return value or Promise
  4. Await async operations
  5. Return results or errors
- [ ] Handle both sync and async code
- [ ] Support top-level await
### 7. Error Handling
- [ ] Catch JavaScript runtime errors:
  - Parse V8 stack traces
  - Map back to TypeScript source (using source maps)
  - Format for LLM feedback
- [ ] Distinguish error types:
  - Runtime errors (TypeError, ReferenceError)
  - Permission errors
  - Op execution errors
### 8. State Management
- [ ] Store runtime state in OpState:
  - Active windows
  - Asset registry reference
  - Permissions
  - Configuration
- [ ] Thread-safe state access
- [ ] Clean up resources on runtime drop
### 9. Dependencies to Add
```toml
[dependencies]
# (existing dependencies)
deno_core = "0.331"
v8 = "0.104"
```
### 10. Isolation and Security
- [ ] Ensure runtime isolation (no file system access)
- [ ] No network access (except through permitted ops)
- [ ] Limited execution time (timeout)
- [ ] Resource limits (memory, CPU)
## Acceptance Criteria
- [ ] JavaScript executes successfully in deno_core
- [ ] Rust ops are callable from JavaScript
- [ ] Permission checks prevent unauthorized actions
- [ ] Async operations work correctly with tokio
- [ ] Runtime errors are captured and formatted
- [ ] State is properly shared between ops
- [ ] Resources are cleaned up properly
- [ ] Performance is acceptable (< 50ms overhead)
## Dependencies
- Requires: #[TypeScript Compilation Pipeline]
- Requires: #[Permissions System]
- Requires: #[Rust Bindings & SDK Generation]
## Related Issues
- #2 Architecture Documentation
- #[GUI Window Manager]
- #[Media Rendering]