## Objective
Implement the pack asset loading system that manages images, videos, audio, hypno animations, and wallpapers with mood-based runtime selection and optional tag filtering.
## Module Structure
```mermaid
graph TB
    subgraph "src/assets/"
        AssetMod[mod.rs]
        Loader[loader.rs]
        Types[types.rs]
        Registry[registry.rs]
        Selector[selector.rs]
    end
    
    Loader --> Types
    Registry --> Types
    Selector --> Registry
    AssetMod --> Loader
    AssetMod --> Registry
    AssetMod --> Selector
```
## Asset Type Hierarchy
```mermaid
classDiagram
    class Asset {
        <<enumeration>>
        +Image(ImageAsset)
        +Video(VideoAsset)
        +Audio(AudioAsset)
        +Hypno(HypnoAsset)
        +Wallpaper(WallpaperAsset)
        +get_path() PathBuf
        +get_tags() Vec~String~
        +matches_tags() bool
        +matches_all_tags() bool
        +load_data() Result~()~
    }
    
    class ImageAsset {
        +PathBuf path
        +Vec~String~ tags
        +Option~ImageData~ data
        +u32 width
        +u32 height
    }
    
    class VideoAsset {
        +PathBuf path
        +Vec~String~ tags
        +Duration duration
        +u32 width
        +u32 height
    }
    
    class AudioAsset {
        +PathBuf path
        +Vec~String~ tags
        +Duration duration
    }
    
    class HypnoAsset {
        +PathBuf path
        +Vec~String~ tags
        +Vec~Frame~ frames
        +bool is_animated
    }
    
    class WallpaperAsset {
        +PathBuf path
        +Vec~String~ tags
        +Option~ImageData~ data
    }
    
    class AssetRegistry {
        +HashMap assets_by_type
        +HashMap tag_index
        +get_by_type() Vec~Asset~
        +filter_by_tags() Vec~Asset~
    }
    
    class AssetSelector {
        +AssetRegistry registry
        +get_for_mood() Option~Asset~
        +get_with_tags() Option~Asset~
        +filter_and_select() Option~Asset~
    }
    
    Asset --> ImageAsset
    Asset --> VideoAsset
    Asset --> AudioAsset
    Asset --> HypnoAsset
    Asset --> WallpaperAsset
    AssetRegistry --> Asset
    AssetSelector --> AssetRegistry
```
## Asset Loading Flow
```mermaid
flowchart TD
    Start([Load Pack]) --> ReadConfig[Read pack config.yaml]
    ReadConfig --> ParseAssets[Parse Asset Definitions]
    
    ParseAssets --> CreateRegistry[Create AssetRegistry]
    
    CreateRegistry --> IterateAssets[Iterate Asset Definitions]
    IterateAssets --> CheckFile{File Exists?}
    
    CheckFile -->|No| WarnMissing[Warn: Missing File]
    CheckFile -->|Yes| ReadMetadata[Read File Metadata]
    
    WarnMissing --> NextAsset{More Assets?}
    ReadMetadata --> ValidateFormat{Valid Format?}
    
    ValidateFormat -->|No| WarnInvalid[Warn: Invalid Format]
    ValidateFormat -->|Yes| CreateAsset[Create Asset Object]
    
    WarnInvalid --> NextAsset
    CreateAsset --> IndexTags[Index by Tags]
    IndexTags --> AddToRegistry[Add to Registry]
    AddToRegistry --> NextAsset
    
    NextAsset -->|Yes| IterateAssets
    NextAsset -->|No| CreateSelector[Create AssetSelector]
    CreateSelector --> Ready([Registry Ready])
```
## Runtime Asset Selection with Optional Tags
```mermaid
flowchart TD
    Start([Op Called: op_show_image]) --> GetSettings[Get Settings Reference]
    GetSettings --> GetMood[Read Current Mood]
    
    GetMood --> CheckOptTags{Optional tags<br/>provided?}
    
    CheckOptTags -->|No| UseMoodOnly[Use Mood Tags Only]
    CheckOptTags -->|Yes| CombineTags[Combine Mood + Optional Tags]
    
    UseMoodOnly --> FilterByMood[Filter Assets by Mood Tags]
    CombineTags --> FilterByBoth[Filter Assets by BOTH<br/>Mood AND Optional Tags]
    
    FilterByMood --> CheckFiltered1{Any Match?}
    FilterByBoth --> CheckFiltered2{Any Match?}
    
    CheckFiltered1 -->|No| FallbackAll1[Fallback to All Assets]
    CheckFiltered1 -->|Yes| SelectFiltered1[Select Random from Filtered]
    
    CheckFiltered2 -->|No| FallbackMoodOnly[Fallback to Mood Only]
    CheckFiltered2 -->|Yes| SelectFiltered2[Select Random from Filtered]
    
    FallbackMoodOnly --> FilterByMood
    FallbackAll1 --> SelectAll[Select Random from All]
    
    SelectFiltered1 --> LoadData[Lazy Load Asset Data]
    SelectFiltered2 --> LoadData
    SelectAll --> LoadData
    
    LoadData --> CheckLoad{Load Success?}
    CheckLoad -->|No| Error[Error: Cannot Load Asset]
    CheckLoad -->|Yes| Return[Return Asset]
    
    Return --> End([Asset to Op])
```
## Tag Filtering Logic
```mermaid
flowchart LR
    subgraph "Current Mood"
        MoodTags[Mood Tags:<br/>nature, landscape, outdoor]
    end
    
    subgraph "Optional Tags from API"
        OptTags[Optional Tags:<br/>beach, sunny]
    end
    
    subgraph "Combined Filter"
        Required[Must have mood tags:<br/>nature OR landscape OR outdoor]
        Additional[AND must have:<br/>beach AND sunny]
    end
    
    subgraph "Asset Pool"
        Asset1[beach.jpg<br/>tags: beach, sunny, landscape]
        Asset2[forest.jpg<br/>tags: forest, mountain, landscape]
        Asset3[sunny-beach.jpg<br/>tags: beach, sunny, nature]
        Asset4[mountain.jpg<br/>tags: mountain, outdoor]
    end
    
    MoodTags --> Required
    OptTags --> Additional
    
    Required --> Filter[Filter Assets]
    Additional --> Filter
    
    Filter -->|matches| Asset1
    Filter -.no sunny.-> Asset2
    Filter -->|matches| Asset3
    Filter -.no beach or sunny.-> Asset4
    
    Asset1 --> Pool[Filtered Pool]
    Asset3 --> Pool
    Pool -->|random| Selected[Selected Asset]
```
## Mood-Based Filtering Logic
```mermaid
flowchart LR
    subgraph "Settings"
        CurrentMood[current_mood:<br/>"Nature"]
    end
    
    subgraph "Pack Moods"
        Nature[Nature Mood<br/>tags: nature, landscape, outdoor]
        Animals[Animals Mood<br/>tags: animal]
        Spirals[Spirals Mood<br/>tags: spiral]
    end
    
    subgraph "Asset Registry"
        Asset1[beach.jpg<br/>tags: beach, sunny, landscape]
        Asset2[forest.jpg<br/>tags: forest, mountain, landscape]
        Asset3[bunny.mp4<br/>tags: bunny, animal]
        Asset4[spiral.gif<br/>tags: spiral]
    end
    
    CurrentMood -->|lookup| Nature
    Nature -->|filter by tags| Filter[Tag Filter:<br/>nature OR landscape OR outdoor]
    
    Filter -->|matches| Asset1
    Filter -->|matches| Asset2
    Filter -.no match.-> Asset3
    Filter -.no match.-> Asset4
    
    Asset1 --> Pool[Filtered Asset Pool]
    Asset2 --> Pool
    Pool -->|random select| Selected[Selected Asset]
```
## Lazy Loading Strategy
```mermaid
stateDiagram-v2
    [*] --> Metadata: Asset Created
    Metadata --> Loading: load_data() called
    Loading --> Loaded: Success
    Loading --> Error: Failure
    Loaded --> Cached: Store in memory
    Cached --> Evicted: LRU eviction
    Evicted --> Metadata: Free memory
    Error --> Metadata: Retry possible
    
    note right of Metadata
        Only path and tags
        stored initially
    end note
    
    note right of Cached
        Full image/video data
        kept in memory
    end note
```
## Asset Selector API
```mermaid
classDiagram
    class AssetSelector {
        +select_for_op(asset_type, mood, optional_tags) Option~Asset~
        +get_random_image(mood, tags) Option~Asset~
        +get_random_video(mood, tags) Option~Asset~
        +get_random_audio(mood, tags) Option~Asset~
        +get_random_hypno(mood, tags) Option~Asset~
        +get_random_wallpaper(mood, tags) Option~Asset~
        -filter_by_mood_tags(assets, mood) Vec~Asset~
        -filter_by_additional_tags(assets, tags) Vec~Asset~
        -filter_by_all_tags(assets, mood, tags) Vec~Asset~
        -select_random(assets) Option~Asset~
    }
    
    class Mood {
        +String name
        +Vec~String~ tags
        +String prompt
        +String description
    }
    
    class Settings {
        +Option~String~ current_mood
        +get_active_mood() Option~Mood~
    }
    
    AssetSelector --> Mood : uses
    AssetSelector --> Settings : reads
```
## Integration with Ops Layer
```mermaid
sequenceDiagram
    participant LLM
    participant Deno as deno_core
    participant Op as op_show_image
    participant Selector as AssetSelector
    participant Registry as AssetRegistry
    participant FS as Filesystem
    
    LLM->>Deno: image.show({ tags: ['beach', 'sunny'] })
    Deno->>Op: Call op_show_image(options)
    Op->>Op: Extract optional tags: ['beach', 'sunny']
    
    Op->>Selector: select_for_op(Image, mood, ['beach', 'sunny'])
    Selector->>Registry: Get all images
    Registry->>Selector: All image assets
    
    Selector->>Selector: Filter by mood "Nature"<br/>(nature, landscape, outdoor)
    Selector->>Selector: Further filter by tags<br/>(beach AND sunny)
    Selector->>Selector: Result: [beach.jpg, sunny-beach.jpg]
    Selector->>Selector: Random select
    Selector->>Op: beach.jpg
    
    Op->>FS: Load beach.jpg
    FS->>Op: Image data
    Op->>Deno: ImageHandle
    Deno->>LLM: ImageHandle
    
    Note over LLM,Registry: LLM never sees full asset list
```
## Fallback Strategy
```mermaid
stateDiagram-v2
    [*] --> FilterMoodAndTags: Start with mood + optional tags
    
    FilterMoodAndTags --> CheckResults1: Apply combined filter
    CheckResults1 --> Success: Assets found
    CheckResults1 --> FallbackMood: No matches
    
    FallbackMood --> CheckResults2: Filter by mood only
    CheckResults2 --> Success: Assets found
    CheckResults2 --> FallbackAll: No matches
    
    FallbackAll --> CheckResults3: Get all assets of type
    CheckResults3 --> Success: Assets found
    CheckResults3 --> Error: No assets at all
    
    Success --> [*]: Return random asset
    Error --> [*]: Return error
```
## Tasks
### 1. Asset Management Structure
- [ ] Create asset module structure (see diagram)
- [ ] Define module exports
### 2. Asset Type Definitions
- [ ] Define `Asset` enum with variants
- [ ] Implement asset-specific types
- [ ] Add metadata fields
- [ ] Implement `matches_tags()` method
- [ ] Implement `matches_all_tags()` method for AND logic
### 3. Asset Registry
- [ ] Implement `AssetRegistry`
- [ ] Thread-safe access with `Arc<RwLock<>>`
- [ ] Tag indexing for fast queries
- [ ] Type-based indexing
### 4. Asset Selector with Tag Support
- [ ] Implement `AssetSelector` struct
- [ ] Mood-based filtering logic
- [ ] **Optional tags filtering (AND logic)**
- [ ] Combined mood + optional tags filtering
- [ ] Random selection from filtered sets
- [ ] Fallback strategy (tags → mood → all)
- [ ] Integration with Settings for current mood
### 5. Tag Filtering Logic
- [ ] Filter by mood tags (OR logic)
- [ ] Filter by optional tags (AND logic)
- [ ] Combine both filters
- [ ] Implement fallback when no matches
- [ ] Log filtering decisions
### 6. Asset Loading
- [ ] Implement lazy loading
- [ ] Metadata extraction on init
- [ ] LRU cache for loaded data
- [ ] Async loading support
### 7. Mood Support
- [ ] Load mood definitions from pack
- [ ] Implement tag-based filtering
- [ ] Runtime mood reading from settings
- [ ] Fallback when no mood set
### 8. Dependencies to Add
```toml
[dependencies]
image = "0.25"
walkdir = "2"
rand = "0.8"  # For random selection
```
### 9. Validation
- [ ] Validate asset files exist
- [ ] Check file formats
- [ ] Warn about missing assets
- [ ] Warn if mood has no matching assets
- [ ] Warn if optional tags too restrictive
## Example Usage from Ops
```rust
// In op_show_image
async fn op_show_image(
    state: Rc<RefCell<OpState>>,
    options: ImageOptions,
) -> Result<ImageHandle> {
    let asset_selector = state.borrow().borrow::<Arc<AssetSelector>>();
    let settings = state.borrow().borrow::<Arc<Settings>>();
    
    // Get current mood from settings
    let current_mood = settings.runtime.pack.mood.as_ref();
    
    // Extract optional tags from options
    let optional_tags = options.tags.as_ref();
    
    // Select asset based on mood + optional tags
    let asset = asset_selector
        .select_for_op(
            AssetType::Image, 
            current_mood,
            optional_tags
        )
        .ok_or(anyhow!("No suitable image assets found"))?;
    
    // Load and render
    let image_data = asset.load_data()?;
    let window = create_window_with_image(image_data, options)?;
    
    Ok(ImageHandle::new(window.handle()))
}
```
## Tag Filtering Examples
```rust
// Example 1: Mood only (no optional tags)
// Mood: "Nature" with tags [nature, landscape, outdoor]
// Result: All assets with any of those tags
let asset = selector.select_for_op(
    AssetType::Image,
    Some("Nature"),
    None
);
// Could return: beach.jpg, forest.jpg, mountain.jpg, etc.
// Example 2: Mood + optional tags
// Mood: "Nature" with tags [nature, landscape, outdoor]
// Optional: [beach, sunny]
// Result: Assets with (mood tags) AND (beach AND sunny)
let asset = selector.select_for_op(
    AssetType::Image,
    Some("Nature"),
    Some(&vec!["beach".to_string(), "sunny".to_string()])
);
// Returns: Only assets that have a mood tag AND have both beach AND sunny
// Example 3: Fallback behavior
// If no assets match mood + optional tags, fall back to mood only
// If no assets match mood, fall back to all assets of type
```
## Performance Considerations
```mermaid
graph LR
    subgraph "Startup (Fast)"
        A[Parse config.yaml] --> B[Create metadata only]
        B --> C[Build tag index]
        C --> D[Ready in <100ms]
    end
    
    subgraph "First Access"
        E[Asset selected] --> F[Filter by mood + tags]
        F --> G[Random select]
        G --> H[Load from disk]
        H --> I[Cache in memory]
    end
    
    subgraph "Subsequent Access"
        J[Asset selected] --> K[Filter cached]
        K --> L[Random select]
        L --> M[Return from cache]
    end
```
## Acceptance Criteria
- [ ] Assets can be loaded from pack directory
- [ ] Mood-based filtering works correctly
- [ ] **Optional tags filtering works (AND logic)**
- [ ] **Combined mood + optional tags filtering works**
- [ ] **Fallback strategy works (tags → mood → all)**
- [ ] Random selection from filtered sets
- [ ] Lazy loading reduces startup time
- [ ] Memory usage is reasonable
- [ ] Missing/invalid assets are handled gracefully
- [ ] Asset selection is transparent to LLM
- [ ] Integration with ops layer works
- [ ] Appropriate warnings when filters too restrictive
## Dependencies
```mermaid
graph LR
    Issue2[#2 Core Init] -->|required by| This[Issue #3]
    This -->|required by| Issue10[#10 Image Rendering]
    This -->|required by| Issue11[#11 Video Rendering]
    This -->|required by| Issue12[#12 Audio Playback]
    This -->|required by| Issue6[#6 deno_core Ops